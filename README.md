## Многопользовательский менеджер паролей
### Чем проект должен стать
Многопользовательское, однооконное, эргономичное приложение, c сменяющимся контентом, неограниченным количеством регистрируемых изолированных аккаунтов, хранящее в локальной/удалённой(на выбор текущего пользователя) БД записи аккаунтов и представляющее их по категориям, которые могут быть настроены каждым конкретным пользователем в отдельности и под себя.
___

### Описание реализованной технической стороны проекта:
#### Правила по структурированию кода
Члены типов объединены в _#region_ по принципу подобия(поля к полям, методы к методам и т.д.), блоки _#region_ же в свою очередь выстроены в определённой последовательности, используемой во всех типах(сначала поля, далее конструкторы, свойства, методы и т.д.). Что даёт не малое удобство при работе с кодом, поиске чего-либо – как самому разработчику, так и тому, кто будет поддерживать такой код.

#### Архитектурные решения:
* Проект разделён на сбороки, с целью изолирования ответственности каждой от остальных. Данный подход в контексте паттерна _MVVM_ даёт модульность на уровне слоёв и в случае необходимости – подменяемость каждого слоя(_Model_/_View_/_ViewModel_), находящегося в отдельной сборке, с минимум усилий, нежели если бы это была одна монолитная сборка.<br/>
\* Один из смыслов архитектурного паттерна _MVVM_ – в случае смены UI технологии переписывать только _View_, не внося изменения при этом в _ViewModel_ и _Model_ слои.

* Краткий обзор сборок, их содержания и зон ответственности:

  * __PasswordManager.M__ – сборка, ответственная за извлечение/сохранение данных(БД) и обработку их бизнесс логикой во время этих операций.<br/>
  Содержит в себе: Модели(_Model_ – один из слоёв паттерна _MVVM_), некоторые из которых реализуют интерфейс _IAccountsDataRepository_, для подменяемости друг друга по средствам Полиморфизма – паттерн _Repository_(Репозиторий); Тип _MDatabaseRepositoriesFacade_ – паттерн _Facade_(Фасад), являющийся точкой доступа к различным БД, используемый во _ViewModel_.

  * __PasswordManager.VM__ – сборка, ответственная за передачу данных, по сути являющаяся инфраструктурой между _Model_ и _View_ слоями.<br/>
  Содержит в себе: Модели-Представления(_ViewModel_– один из слоёв паттерна _MVVM_); Инфраструктуру _AVMBase_ визуального обновления во _View_ значений интерфейсных свойств данных _ViewModel_; Инфраструктуру _AVMInfrastructure_, содержащую свойство _MDatabaseRepositoriesFacade_ позволяющее управлять различными БД и свойство _ChangingContentService_ позволяющее менять текущие контентные Представления(_View_); Тип _RelayCommand_ реализующий интерфейс _ICommand_ – паттерн _Command_(Команда), объекты которого по средствам интерфейстных свойств _ViewModel_ связанны через привязку с графическими элементами во _View_ и методы параметризирующие эти объекты выполняются в _ViewModel_ в результате действий пользователя в UI во _View_.

  * __PasswordManager.V__ – сборка, ответственная за визуальное представление, поступающих из _ViewModel_ слоя данных, в своём UI.<br/>
  Содержит в себе: Представления(_View_ – один из слоёв паттерна _MVVM_) и всё, что необходимо для визуального отображения UI(стили, шаблоны, цвета и т.д.).

  * __PasswordManager.DTO__ – сборка, содержащая набор типов, задача экземпляров которых пересылать данные между слоями паттерна _MVVM_ – паттерн _DTO_(_Data Transfer Object_).

  * __WPFMaterial__ – сборка, содержащая индивидуально настроенные контролы(_WPF Custom Control_) для их использования в слое Представлений(_View_).

* Для того, чтобы получить централизованность работы самого клиента(в данном случае СУБД), обеспечить БОльшую устойчивость, вне зависимости от выбора БД для взаимодействия с данными зарегистрированных аккаунтов – существует своя локальная БД, для хранения данных самого приложения. Таким образом существуют следующие БД: отдельная БД SQLite хранит данные самого приложения(запомнить данные для входа, временно хранить данные текущего вошедшего аккаунта и т.д.) и отдельная БД SQLite при выборе соединения с которой хранятся аккаунты зарегистрированные при выбранном подключении к ней и их записи, которую может подменять БД SQL в которой так же хранятся аккаунты зарегистрированные при выбранном подключении к ней и их записи.

* Потому как перед отображением формы авторизации необходимо обратиться к БД, с целью получения данных для возможного заполнения полей авторизации, а конструктор типа _VMAuthorization_ не является местом выполнения серьёзных операций, то выбран уровень _App.xaml.cs_ исполнения слоя _View_.

* Для того, чтобы иметь возможность в инфраструктуре находящейся во _ViewModel_ типах удобно обращаться к двум БД, представляющим разные сущности(БД приложения и БД хранящая зарегистрированные аккаунты и их записи) из одной точки, на стороне сборки _Model_ реализован паттерн _Facade_, который представляет композицию этих двух БД в одном типе, объект же этого типа _MDatabaseRepositoriesFacade_ будет представлять свойство _MDatabaseRepositoriesFacade_(являющееся той самой точкой доступа ко всем БД) из абстрактного класса _AVMInfrastructure_, содержащего инфраструктуру взаимодействия с БД _MDatabaseRepositoriesFacade_ и инфраструктуру смены контента окна приложения _ChangingContentService_.

* Для того, чтобы обеспечить возможность подключения к разным типам БД и при этом одинаковому взаимодействию с этими БД, в сборке __PasswordManager.M__ реализован паттерн _Repository_(Репозиторий), позволяющий, по средствам одной из основополагающих парадигм ООП – Полиморфизма, подменять реализации. В существующем виде тип подключения БД устанавливается при запуске приложения, но затем это станет возможным так же в любой момент работы приложения и архитектурно замена реализации типа подключения уже предусмотрена из любого типа _ViewModel_ с родителем инфраструктурой _AVMInfrastructure_, содержащим член свойство _MDatabaseRepositoriesFacade_ и через который идёт взаимодействие с БД, выбрав через него свойство только мутатор _MAccountsDataRepository_ установить новый тип подключения к БД присвоив соответствующий объект.

* Решение с инфраструктурой, позволяющей сменять контент основано на UpCust одного и того же объекта _ChangingContent_ к разным интерфейсам, которые он в себе реализовывает. Что помимо прочего, особенно в данном случае, очень уместно позволяет использовать одну из парадигм ООП – Инкапсуляция(т.е. при каждом UpCust к одному из интерфейсов не видно реализации другого интерфейса). Сам UpCust объекта _ChangingContent_ происходит во время параметризирования им соответствующих конструкторов.

* Инфраструктура взаимодействия c БД _MDatabaseRepositoriesFacade_ и смены контента _ChangingContentService_, для большего удобства находится в объекте _InfrastructureArgs_, один и тот же объект которого существует и циркулирует между сменяющимися _ViewModel_, пока существует узловой Node _ViewModel_ в котором внутри сменяются _ViewModel_, что представляется хорошо масштабируемым архитектурным решением на любое количество уровней вложенности контентов _View_.

* Связывание Представлений(_View_) и соответствующих им Моделей-Представлений(_ViewModel_) осуществляется через механизм UI технологии WPF в файле словаря-ресурса _MatchingVVM.xaml_, который добавлен в _App.xaml_ и виден во всём слое _View_, т.е. при подаче _ViewModel_ на свойство _Content_ находящееся во _View_, автоматически сопоставляется и выводится соответствующая ей _View_.

#### UI-UX решения:
* У многих элементов UI, в состоянии доступности, есть всплывающие подсказки, информирующие пользователя:
  * Какие действия могут быть выполнены при помощи этого элемента.
  * В случае элементов-кнопок – от 1 до 3 вариантов лаконичных сочетаний клавиш быстрого нажатия.
  * В случае элементов-индикаторов – информация о изменении в UI.

\* У некоторых элементов UI всплывающая подсказка состоит из комбинации определённых из указанных пунктов и динамически меняется в зависимости от происходящего в UI.

* Хорошо продумана общая эргономика UX – получение фокуса нужными элементами UI(кнопки, поля и т. д.) в каждый конкретный момент, что позволяет комфортно взаимодействовать с приложением при помощи одной клавиатуры.

<br/>
Текущее состояние – достаточно правильное с точки зрения необходимой, для данного случая, общей архитектуры. Проделана не малая, но не окончательная работа с контролами.
